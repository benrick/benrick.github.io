---
layout: post
title: "Parameter and Return Type Interfaces"
date: 2015-06-16 14:00:00 -0400
comments: true
published: true
categories: ["Archive"]
tags: ["SOLID", "Software Craftsmanship", "Interfaces", "Tips"]
permalink: "/post/Parameter-and-Return-Type-Interfaces/"
---
<!-- more -->



<p>At some point, I’m sure you’ve had someone suggest that you use an interface instead of a concrete class as a dependency. Assuming you’re following the Interface Segregation Principle, that could be exactly what you want to do. Well written interfaces can make your code much simpler and more clearly define your dependencies. That’s why Interface Segregation Principle is one of those popular <a href="/post/SOLID-Principles-Software-Craftsmanship-Calendar-Topics" target="_blank">SOLID principles</a> you’re always hearing about.</p> <p><a href="/images/files/NP-Interface-Segregation.jpg"><img title="NP-Interface-Segregation" style="border-top: 0px; border-right: 0px; border-bottom: 0px; border-left: 0px; display: inline" border="0" alt="NP-Interface-Segregation" src="/images/files/NP-Interface-Segregation_thumb.jpg" width="486" height="484"></a> </p> <p>I recently read an interesting <a href="https://twitter.com/DerikWhittaker/status/610425115042426880" target="_blank">tweet from Derik Whittaker</a> talking about using IEnumerable when an ICollection or IList would be the better choice.&nbsp; </p> <blockquote> <p>Ugg, may want to fix your code rather than do this "// ReSharper disable once PossibleMultipleEnumeration"</p></blockquote> <p>This move toward making everything IEnumerable&lt;T&gt; is a trend happening across the C# community. I believe that ReSharper (a tool I use and love) is leading to some of this. When you write a method that takes in a collection as a parameter, and your method does a foreach over that collection, ReSharper will suggest (correctly) to change it to an IEnumerable. This is because you only enumerated it once, and that means that you can be more relaxed in your requirements. </p> <p><strong>Side Note:</strong> IEnumerable is not technically <a href="/post/Foreach-IEnumerable-IEnumerator-and-Duck-Typing" target="_blank">the requirement for a foreach loop</a>.</p> <p>The problem people run into with IEnumerables is that they’re not all collections. IEnumerable&lt;T&gt; just means that there is a method to get an Enumerator. In simple terms, I mean that it’s possible to walk through the items in the enumerable one at a time. Sometimes that requires work that’s more than constant time to get to the next item in the enumerable class. The comment that Derik mentioned in his tweet is one that tells ReSharper to not warn you about a possible issue. That issue is that you might be doing the work of walking through the enumerable more than once. When it sees an enumerable that is enumerated for a second time, you’ll receive this warning.</p> <h3>Keep Your Method Parameters Permissive</h3> <p><a href="/images/files/3364773646_ebc547a3fa_o.jpg"><img title="3364773646_ebc547a3fa_o" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; margin-left: 0px; display: inline; border-top-width: 0px; margin-right: 0px" border="0" alt="3364773646_ebc547a3fa_o" src="/images/files/3364773646_ebc547a3fa_o_thumb.jpg" width="244" align="right" height="184"></a></p> <p>When you’re making a method parameter, you want to make sure that you’re only requiring exactly what you need. In doing this, you’ll likely create interfaces following the Interface Segregation Principle. When dealing with collections, you’re likely to accept an IEnumerable&lt;T&gt; if you only enumerate once. You might accept an ICollection&lt;T&gt; if you need to enumerate a couple of times, allow adding and removing, or need to count the items. If your collection needs random, array-like index access, you should consider using IList&lt;T&gt;.&nbsp; </p> <p>This allows the caller of your method to give you whatever they have at the time. You really don’t care as long as it has what you need. If their object is an IEnumerable that isn’t also an IList, they can convert it before providing it to you. Working this way makes your API much more flexible, since you’re making your minimum requirements clear. </p> <h3>Return Usable Types From Your Methods</h3> <p><a href="/images/files/6555544311_79789a44b9_o.jpg"><img title="6555544311_79789a44b9_o" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; margin-left: 0px; display: inline; border-top-width: 0px; margin-right: 0px" border="0" alt="6555544311_79789a44b9_o" src="/images/files/6555544311_79789a44b9_o_thumb.jpg" width="244" align="right" height="184"></a> </p> <p>Sadly, I see the reverse being pushed as a positive. You will find <a href="http://stackoverflow.com/a/9855752/22381" target="_blank">information telling you to return IEnumerable&lt;T&gt;</a>, so that you can easily change. This, however, means that you’re providing your method’s consumer with no information about the object they’re receiving. If they need access to array-like indexing, they have to call <em>ToList()</em> on your return value in order to use it.</p> <p>Since ICollection&lt;T&gt; implements IEnumerable&lt;T&gt; and IList&lt;T&gt; implements ICollection&lt;T&gt; and IEnumerable&lt;T&gt;, you can return an IList&lt;T&gt; allowing your method’s caller to use IList&lt;T&gt;, ICollection&lt;T&gt;, or IEnumerable&lt;T&gt; depending on their usage. You’re using an interface and still giving the consumer the power of choice. You can avoid tightly coupling to a concrete implementation while still providing a useful return value. </p> <p>I almost never return IEnumerable&lt;T&gt;. I don’t know that the return value will only be enumerated once. That’s outside my current layer of abstraction, so I shouldn’t be dealing with it. The safe bet is just to return a useful collection if that’s what I have. If my value really is enumerable, but not a collection, I will return an IEnumerable. In all other cases, it should be a more useful interface. lists an collections really are cohesive concepts that should be grouped into one object when needed.</p>
