---
layout: post
title: "Using Dynamic Typing When an Interface was Needed"
date: 2010-08-13 10:00:00 -0400
comments: true
published: true
categories: ["blog", "archives"]
tags: ["Blog"]
alias: ["/post/Using-Dynamic-Typing-When-an-Interface-was-Needed", "/post/using-dynamic-typing-when-an-interface-was-needed"]
---
<!-- more -->

<p>Interfaces and base classes allow us a great deal of power in object oriented programming. We are able to accept a base type or interface and be given an implementation or an inheritor and continue working correctly. What if, however, we need to be able to accept more than one type, which have the same methods or properties, but to not share an interface or base class? Often the best answer is to add a common interface to these, so that the shared behavior is defined. In most of my cases when I need to do something like this, it is because I don’t have the source code for one or more of the classes.</p>  <p>Our answer in this case is the dynamic types which we added in to C# 4.0. In this new revision of the language, we are able to declare an object deferring its type until runtime. We will define how we will use the object now, and at runtime our code will attempt to use that object.</p>  <p>The following is some example code showing how to use the dynamic keyword to use two classes interchangeably:</p>  <div id="codeSnippetWrapper">   <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"><span style="color: #0000ff">class</span> Program<br />{<br />    <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> List&lt;DateTime&gt; <br />        Dates = <span style="color: #0000ff">new</span> List&lt;DateTime&gt;();<br /><br />    <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> Main(<span style="color: #0000ff">string</span>[] args)<br />    {<br />        var someClass = <span style="color: #0000ff">new</span> SomeClass(DateTime.Now);<br />        GetEventDate(someClass);<br />        var otherClass = <span style="color: #0000ff">new</span> OtherClass(DateTime.Now);<br />        GetEventDate(otherClass);<br /><br />        var values = Dates.Select(d =&gt; d.ToShortDateString());<br />        Console.WriteLine(<span style="color: #0000ff">string</span>.Join(<span style="color: #006080">&quot;---&quot;</span>, values));<br />    }<br /><br />    <span style="color: #0000ff">private</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> GetEventDate(dynamic objectWithDate)<br />    {<br />        Dates.Add(objectWithDate.Date);<br />    }<br />}<br /><br /><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> SomeClass<br />{<br />    <span style="color: #0000ff">public</span> DateTime Date { get; set; }<br /><br />    <span style="color: #0000ff">public</span> SomeClass(DateTime date)<br />    {<br />        Date = date;<br />    }<br />}<br /><br /><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> OtherClass<br />{<br />    <span style="color: #0000ff">public</span> DateTime Date { get; set; }<br /><br />    <span style="color: #0000ff">public</span> OtherClass(DateTime date)<br />    {<br />        Date = date;<br />    }<br />}<br /></pre>

  <br /></div>

<p>So in this example, if we say that I didn’t have access to <em>OtherClass</em> in order to give it some interface, using the dynamic would allow me to get around this and use a convention-based approach to development. When the alternative is some cluttered approach, I am always in favor of simplifying the readability and usability of my source code. Now there is less of a reason to complain that a certain class from a library or generated code doesn’t implement an interface. (There is still reason, but at least we can avoid some of the issues at play.)</p>
